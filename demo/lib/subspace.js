'use strict';

/** @module lib/subspace
 *
 * @file
 * Implements a Subspace class to represent subspaces of `R^n`.
 */

import Matrix from "./matrix.js";

/**
 * Class representing a subspace.
 *
 * A `Subspace` is represented as the column space of a matrix.  Various
 * operations on the subspace will involve computing a basis, or even an
 * orthonormal basis.
 */
class Subspace {
    /**
     * The subspace `R^n`.
     *
     * @param {integer} n - The dimension of the space.
     * @return {Subspace} The subspace `R^n`.
     */
    static Rn(n) {
        return new Subspace(Matrix.identity(n), {n: n, isBasis: true, isON: true});
    }

    /**
     * The zero subspace of `R^n`.
     *
     * @param {integer} n - The ambient dimension.
     * @return {Subspace} The subspace `{0}`.
     */
    static zero(n) {
        return new Subspace([], {n: n, isBasis: true, isON: true});
    }

    /**
     * Create a Subspace.
     *
     * @param {(Vector[]|Matrix)} generators - A spanning set for the subspace.
     *   If it is a matrix, use the columns of the matrix as the spanning set.
     * @param {Object} hints - Precomputed properties of the subspace.
     * @param {integer} hints.n - The dimension of the ambient R^n.  Only
     *   necessary to provide if `generators` is empty.
     * @param {boolean} hints.isBasis - The generators are linearly independent.
     * @param {boolean} hints.isON - The generators are orthonormal.
     * @throws Will throw an error if the generators do not all have the same
     *   length, or if it can't determine the ambient space R^n.
     */
    constructor(generators, {n, isBasis, isON}={}) {
        /**
         * The dimension of the ambient R^n.
         *
         * @type {integer}
         */
        if(n !== undefined)
            this.n = n;
        else if(generators instanceof Matrix)
            this.n = generators.m;
        else if(generators.length > 0)
            this.n = generators[0].length;
        else
            throw new Error("Cannot determine the ambient R^n from zero generators");

        /**
         * The columns of this matrix span this Subspace.
         *
         * @type {Matrix}
         */
        this.generators = generators instanceof Matrix
            ? generators : new Matrix(...generators).transpose;

        this._basis = isBasis ? this.generators : undefined;

        /** @private */
        this._ONbasis = isON ? this.generators : undefined;
    }

    /**
     * Return a string representation of the Subspace.
     *
     * @param {integer} [precision=4] - The number of decimal places to include.
     * @return {string}
     */
    toString(precision=4) {
        return `Subspace of R^${this.n} spanned by\n`
            + this.generators.toString(precision);
     }

    /**
     * Compute a basis for the subspace.
     *
     * The computed basis will be a subset of `this.generators`.
     *
     * @param {number} [ε=1e-10] - Entries smaller than this value are taken
     *   to be zero for the purposes of pivoting.
     * @return {Matrix} A matrix whose columns form a basis for the Subspace.
     */
    basis(ε=1e-10) {
        if(this._basis) return this._basis;
        this._basis = new Matrix(...this.generators.colBasis(ε)).transpose;
        return this._basis;
    }

    /**
     * Compute an orthonormal basis for the subspace.
     *
     * @param {number} [ε=1e-10] - Vectors shorter than this value are taken to
     *   be zero.
     * @return {Matrix} A matrix whose columns form an orthonormal basis for the
     *   Subspace.
     */
    ONbasis(ε=1e-10) {
        if(this._ONbasis) return this._ONbasis;
        let {Q} = this.generators.QR(ε);
        this._ONbasis = new Matrix(
            ...[...Q.cols()].filter(col => !col.isZero())).transpose;
        if(this._dim === undefined)
            this._dim = this._ONbasis.n;
        return this._ONbasis;
    }

    /**
     * The dimension of the subspace.
     *
     * @type {integer}
     */
    get dim() {
        if(this._dim === undefined)
            this._dim = this.basis().n;
        return this._dim;
    }

    /**
     * Take the sum of two subspaces.
     *
     * This is the subspace generated by the generators of `this` and `other`.
     *
     * @param {Subspace} other - The subspace to add.
     * @return {Subspace} The smallest subspace containing `this` and `other`.
     * @throws Will throw and error of `this.n != other.n`.
     */
    add(other) {
        if(this.n != other.n)
            throw new Error("Tried to add subspaces of different R^n");
        return new Subspace(
            [...this.generators.cols(), ...other.generators.cols()],
            {n: this.n});
    }

    /**
     * Take the intersection of two subspaces.
     *
     * This is the subspace consisting of all vectors contained both in `this`
     * and in `other`.
     *
     * @param {Subspace} other - The subspace to intersect.
     * @param {number} [ε=1e-10] - Entries smaller than this value are taken
     *   to be zero for the purposes of pivoting.
     * @return {Subspace} The largest subspace contained in `this` and `other`.
     * @throws Will throw and error of `this.n != other.n`.
     */
    intersect(other, ε=1e-10) {
        if(this.n != other.n)
            throw new Error("Tried to add subspaces of different R^n");
        return this.orthoComplement(ε).add(
            other.orthoComplement(ε)).orthoComplement(ε);
    }

    /**
     * Compute whether the subspace is all of R^n.
     *
     * @param {number} [ε=1e-10] - Entries smaller than this value are taken
     *   to be zero for the purposes of pivoting.
     * @return {boolean}
     */
    isMaximal(ε=1e-10) {
        return this.basis(ε).n == this.n;
    }

    /**
     * Compute whether the subspace is zero.
     *
     * @param {number} [ε=1e-10] - Entries smaller than this value are taken
     *   to be zero for the purposes of pivoting.
     * @return {boolean}
     */
    isZero(ε=1e-10) {
        return this.basis(ε).n == 0;
    }

    /**
     * Compute the projection matrix onto `this`.
     *
     * @param {number} [ε=1e-10] - Vectors shorter than this value are taken to
     *   be zero when computing an orthonormal basis.
     * @return {Matrix} An `n`x`n` matrix for projection onto `this`.
     */
    projectionMatrix(ε=1e-10) {
        if(this._projectionMatrix) return this._projectionMatrix;
        let Q = this.ONbasis(ε);
        if(this.dim > 0)
            this._projectionMatrix = Q.mult(Q.transpose);
        else
            this._projectionMatrix = Matrix.zero(this.n);
        return this._projectionMatrix;
    }

    /**
     * Compute the orthogonal decomposition of a vector with respect to `this`.
     *
     * This returns the unique pair of vectors `[v1, v2]` such that `v1` is in
     * `this`, `v2` is orthogonal to `this`, and `v1 + v2 = v`.
     *
     * @param {Vector} v - The vector to decompose.
     * @param {number} [ε=1e-10] - Vectors shorter than this value are taken to
     *   be zero when computing an orthonormal basis.
     * @return {Vector[]} Returns `[v1, v2]` as described above.
     * @throws Throws an error if `v.length != this.n`.
     */
    orthoDecomp(v, ε=1e-10) {
        let P = this.projectionMatrix(ε);
        let v1 = P.apply(v);
        return [v1, v.clone().sub(v1)];
    }

    /**
     * Compute the orthogonal projection of a vector onto `this`.
     *
     * This is an alias for `this.orthoDecomp(v, ε)[0]`.
     *
     * @param {Vector} v - The vector to project.
     * @param {number} [ε=1e-10] - Vectors shorter than this value are taken to
     *   be zero when computing an orthonormal basis.
     * @return {Vector} The orthogonal projection.
     * @throws Throws an error if `v.length != this.n`.
     */
    project(v, ε=1e-10) {
        return this.orthoDecomp(v, ε)[0];
    }

    /**
     * Compute the shortest vector from `this` to `v`.
     *
     * This is an alias for `this.orthoDecomp(v, ε)[1]`.
     *
     * @param {Vector} v - The vector to decompose.
     * @param {number} [ε=1e-10] - Vectors shorter than this value are taken to
     *   be zero when computing an orthonormal basis.
     * @return {Vector} The orthogonal projection.
     * @throws Throws an error if `v.length != this.n`.
     */
    complement(v, ε=1e-10) {
        return this.orthoDecomp(v, ε)[1];
    }

    /**
     * Compute the distance of `v` from `this`.
     *
     * This is an alias for `this.complement(v, ε).size`.
     *
     * @param {Vector} v - The vector to measure.
     * @param {number} [ε=1e-10] - Vectors shorter than this value are taken to
     *   be zero when computing an orthonormal basis.
     * @return {number} The distance to `this`.
     * @throws Throws an error if `v.length != this.n`.
     */
    distanceTo(v, ε=1e-10) {
        return this.complement(v, ε).size;
    }

    /**
     * Check if this Subspace contains a Vector.
     *
     * This means that the vector is a linear combination of the generators.
     *
     * @param {Vector} vec - The vector to test.
     * @param {number} [ε=1e-10] - Vectors shorter than this value are taken to
     *   be zero.
     * @return {boolean}
     * @throws Will throw an error if `vec.length != this.n`.
     */
    contains(vec, ε=1e-10) {
        if(this.n != vec.length)
            throw new Error("Vector has the wrong number of entries");
        if(this.isMaximal(ε))
            return true; // Nothing to check!
        if(this.isZero(ε))
            return vec.isZero(ε); // Nothing to check!
        return this.distanceTo(vec) < ε;
    }

    /**
     * Check if a Vector is orthogonal to `this`.
     *
     * @param {Vector} vec - The vector to test.
     * @param {number} [ε=1e-10] - Vectors shorter than this value are taken to
     *   be zero.
     * @return {boolean}
     * @throws Will throw an error if `vec.length != this.n`.
     */
    isOrthogonalTo(vec, ε=1e-10) {
        if(this.n != vec.length)
            throw new Error("Vector has the wrong number of entries");
        if(this.isMaximal(ε))
            return vec.isZero(ε); // Nothing to check!
        if(this.isZero(ε))
            return true;
        return this.project(vec).sizesq <= ε*ε;
    }

    /**
     * Check if this Subspace is contained in another Subspace.
     *
     * @param {Subspace} other - The subspace to test.
     * @param {number} [ε=1e-10] - Entries smaller than this value are taken
     *   to be zero for the purposes of pivoting.
     * @return {boolean}
     */
    isSubspaceOf(other, ε=1e-10) {
        if(this.n != other.n)
            return false;
        let B = this.basis(ε);
        return [...B.cols()].every(col => other.contains(col, ε));
    }

    /**
     * Check if this Subspace is equal to `other`.
     *
     * Two subspaces are equal if they have the same ambient dimension, the same
     * dimension, and contain each other.
     *
     * @param {Subspace} other - The subspace to compare.
     * @param {number} [ε=1e-10] - Entries smaller than this value are taken
     *   to be zero for the purposes of pivoting.
     * @return {boolean}
     */
    equals(other, ε=1e-10) {
        this.basis(ε); other.basis(ε);  // Compute dimension
        if(this.dim !== other.dim)
            return false;
        return this.isSubspaceOf(other, ε);
    }

    /**
     * Find the orthogonal complement of `this`.
     *
     * @param {number} [ε=1e-10] - Entries smaller than this value are taken
     *   to be zero for the purposes of pivoting.
     * @return {Subspace}
     */
    orthoComplement(ε=1e-10) {
        if(this.isZero(ε))
            return Subspace.Rn(this.n);
        return this.generators.leftNullSpace(ε);
    }
}

export default Subspace;
